\chapter{Results}
\label{results}
\section{Comparison of Formal Methods and Genetic Programming}
This chapter shall present the performance of a simulated real-time system where the scheduling heuristic is generated by genetic programming.
The results shall be compared to the RLP scheduling algorithm, as it is the most sophisticated of all formal algorithms presented in this work.
The comparison is made with respect to various parameters: mean task skip factor, the \textit{Gini} coefficient, QoS and wasted CPU time.

In the test examples, the NSGA-II variant of the genetic algorithm was used.
The parameters of the genetic algorithm are listed in the following table.
\begin{table}[H]
\centering
\begin{tabular}{|
>{\columncolor[HTML]{EFEFEF}}l |
>{\columncolor[HTML]{FFFFFF}}c |}
\hline
Population size    & 20 \\ \hline
Generation number  & 50 \\ \hline
Maximum tree depth & 5  \\ \hline
\end{tabular}
\end{table}
The heuristic was trained on task sets with six different utilization factors: 
\begin{equation*}
\{ 0.9, 1, 1.1, 1.2, 1.3, 1.4 \}.
\end{equation*}
$10$ different task sets were created for each utilization factor, which gives the total amount of $60$ training task sets.
For testing the heuristic, the utilization factor varied from $0.9$ to $1.6$ with $0.05$ increment.
The test task sets are generated in a $10$ times larger amount per utilization factor than the training sets.
The task sets for both training and testing were generated by the \textit{UUniFast} algorithm.

Fig. \ref{heur_v_rlp} shows the test results for an evolved heuristic defined by the following expression:
\begin{equation*}
c_i \cdot w_i + c_i \cdot d_i.
\end{equation*}
The evolved heuristic is compared to the RLP algorithm with respect to QoS measure.
QoS values for all the task sets are shown by the scatter plot.
The line graph shows the eighth degree polynomial regression model of the scattered data.
\begin{figure}[ht]
    \centering
    \includegraphics[width=1\textwidth]{images/heur_v_rlp.pdf}
    \caption{A comparison of the RLP algorithm and the evolved heuristic with respect to the QoS measure.}
    \label{heur_v_rlp}
\end{figure}

In the following text, the performance of the evolved heuristic shall be presented through two examples of task sets.
The utilization of both task sets equals 1.2 and the minimal skip factor for the RLP algorithm is set to 2.
% The considered heuristic is described by the following expression:
% \begin{equation*}
% c_i \cdot \frac{S_d}{\frac{S_d}{c_i}} = c_i^2.
% \end{equation*}

In the first example, the schedule produced by the heuristic is compared to the RLP schedule from Section \ref{skip_algs} shown in Fig. \ref{rlp_schedule}.
QoS measure achieved by the RLP algorithm for this task set equals $0.73$, with a total of $9$ time units of wasted CPU time.
The schedule for this task set provided by the evolved heuristic is shown in Fig. \ref{rlp_heur_comp1}.
\begin{figure}[ht]
    \centering
    \includegraphics[width=1\textwidth]{images/heur_vs_RLP_example1.pdf}
    \caption{A schedule produced by the evolved heuristic for task set 1.}
    \label{rlp_heur_comp1}
\end{figure}
This schedule results in two additional successfully completed instances, increasing the QoS measure to $0.87$. 
There is only one aborted task instance and the amout of wasted CPU time equals $4$.

The second task set is defined by the following parameters:
\begin{table}[H]
\begin{center}
\begin{tabular}{|
>{\columncolor[HTML]{FFFFFF}}c |c|c|}
\hline
   & \cellcolor[HTML]{FFFFFF}\textbf{$T_i$} & \cellcolor[HTML]{FFFFFF}\textbf{$c_i$} \\ \hline
\textbf{$\tau_1$} & 15                         & 6                          \\ \hline
\textbf{$\tau_2$} & 12                          & 4                          \\ \hline
\textbf{$\tau_3$} & 6                          & 3                          \\ \hline
\end{tabular}
\end{center}
\end{table}

Fig. \ref{rlp_example_2} shows the schedule produced by the RLP algorithm.
\begin{figure}[ht]
    \centering
    \includegraphics[width=1\textwidth]{images/skipover_RLP_3.pdf}
    \caption{A schedule produced by RLP algorithm for task set 2.}
    \label{rlp_example_2}
\end{figure}
In this example, the amount of skipped or aborted tasks equals 8 instances of total 19.
The aborted instances were executing for a total of $19$ time units.

The schedule provided by the evolved heuristic is shown in Fig. \ref{heur_example_2}.
\begin{figure}[ht]
    \centering
    \includegraphics[width=1\textwidth]{images/heur_vs_RLP_example2.pdf}
    \caption{A schedule produced by the evolved heuristic for task set 2.}
    \label{heur_example_2}
\end{figure}
The number of successfully completed tasks is increased to 13.
Regarding the QoS measure and the wasted CPU time, the heuristic yields better results.
However, the schedule results in two consecutive skipped instances of the same task.
Consequently, there is a significant difference between mean skip factors of the tasks in the task set.
Therefore, the heuristic is not applicable to this task set.

% The parameters of the first task set are defined as follows:
% \begin{table}[htbp]
% \begin{center}
% \begin{tabular}{|
% >{\columncolor[HTML]{FFFFFF}}c |c|c|}
% \hline
%    & \cellcolor[HTML]{FFFFFF}\textbf{$T_i$} & \cellcolor[HTML]{FFFFFF}\textbf{$c_i$} \\ \hline
% \textbf{$\tau_1$} & 10                         & 2                          \\ \hline
% \textbf{$\tau_2$} & 6                          & 2                          \\ \hline
% \textbf{$\tau_3$} & 3                          & 2                          \\ \hline
% \end{tabular}
% \end{center}
% \end{table}
% Fig. \ref{rlp_1} shows a schedule produced by RLP algorithm. 
% \begin{figure}[ht]
%     \centering
%     \includegraphics[width=1\textwidth]{images/res_skipover_RLP.pdf}
%     \caption{A schedule produced by RLP algorithm for task set 1.}
%     \label{rlp_1}
% \end{figure}
% The skip factors for tasks $\tau_1$, $\tau_2$ and $\tau_3$ equal $4$, $6$, and $2$, respectively.
% The mean skip factor for all tasks equals $4.17$.
% Since there are four aborted or skipped instances of task $\tau_3$, the QoS parameter equals $0.78$.
% The two aborted instances of task $\tau_3$ at time instants $t=18$ and $t=24$ result in $2$ units of wasted CPU time.

% Fig. \ref{heur_1} shows the schedule for the first task set produced by an evolved heuristic.
% This task set was used as a training set for heuristic evolution.
% The heuristic is represented by the following expression:
% \begin{equation*}
% p_i = N_r \cdot c_i,
% \end{equation*}
% where $p_i$ is the priority of the current task, $N_r$ is the number of remaining (unscheduled) jobs and $c_i$ is the processing time. 
% The relating schedule is shown in figure \ref{heur_1}.
% \begin{figure}[ht]
%     \centering
%     \includegraphics[width=1\textwidth]{images/skipover_heur.pdf}
%     \caption{A schedule produced by evolved heuristic for task set 1.}
%     \label{heur_1}
% \end{figure}
% The number of successfully completed tasks is increased to 15, improving the QoS value to $0.83$.
% Since there are no aborted task instances, there is no wasted CPU time.
% The mean skip factor of task $\tau_3$ now equals $3.75$, thus the overall mean skip factor is increased to $4.25$.

% The second task set parameters are listed in the following table:
% \begin{table}[H]
% \begin{center}
% \begin{tabular}{|
% >{\columncolor[HTML]{FFFFFF}}c |c|c|}
% \hline
%    & \cellcolor[HTML]{FFFFFF}\textbf{$T_i$} & \cellcolor[HTML]{FFFFFF}\textbf{$c_i$} \\ \hline
% \textbf{$\tau_1$} & 10                         & 7                          \\ \hline
% \textbf{$\tau_2$} & 6                          & 3                          \\ \hline
% \end{tabular}
% \end{center}
% \end{table}
% Fig.s \ref{rlp_2} and \ref{heur_2} show the schedules produced by RLP algorithm and evolved heuristics.
% \begin{figure}[ht]
%     \centering
%     \includegraphics[width=1\textwidth]{images/skipover_RLP_2.pdf}
%     \caption{A schedule produced by RLP algorithm for task set 2.}
%     \label{rlp_2}
% \end{figure}
% \begin{figure}[ht]
%     \centering
%     \includegraphics[width=1\textwidth]{images/skipover_heur_2.pdf}
%     \caption{A schedule produced by evolved heuristic for task set 2.}
%     \label{heur_2}
% \end{figure}

% Both schedules yield the same amount of aborted or skipped instances.
% Regarding the QoS value only, the schedules are equal.
% The mean skip factor of the heuristic schedule equals $2.83$, which is slightly greater than the mean skip factor of the RLP schedule ($2.33$). 
% However, the latter schedule results in two consecutive skipped instances of the same task.
% Consequently, there is a significant difference between mean skip factors of the two tasks.
% Therefore, the heuristic is not applicable to this task set.

% The parameters of the second task set are given in the following table.
% \begin{table}[H]
% \begin{center}
% \begin{tabular}{|
% >{\columncolor[HTML]{FFFFFF}}c |c|c|}
% \hline
%    & \cellcolor[HTML]{FFFFFF}\textbf{$T_i$} & \cellcolor[HTML]{FFFFFF}\textbf{$c_i$} \\ \hline
% \textbf{$\tau_1$} & 15                         & 6                          \\ \hline
% \textbf{$\tau_2$} & 12                          & 4                          \\ \hline
% \textbf{$\tau_3$} & 6                          & 3                          \\ \hline
% \end{tabular}
% \end{center}
% \end{table}

% The schedules produced by the RLP algorithm and the evolved heuristic are shown in Fig.s \ref{rlp_3} and \ref{heur_3}.
% \begin{figure}[ht]
%     \centering
%     \includegraphics[width=1\textwidth]{images/skipover_RLP_3.pdf}
%     \caption{A schedule produced by RLP algorithm for task set 3.}
%     \label{rlp_3}
% \end{figure}
% \begin{figure}[ht]
%     \centering
%     \includegraphics[width=1\textwidth]{images/skipover_heur_3.pdf}
%     \caption{A schedule produced by evolved heuristic for task set 3.}
%     \label{heur_3}
% \end{figure}
% The heuristic surpasses the RLP algorithm according to the QoS and wasted CPU time measures.
% The problem with skipping consecutive time instances is more significant in this case, as it occurs with two tasks, $\tau_2$ and $\tau_3$.

The results of testing the RLP algorithm and the evolved heuristic through the two described task sets are summarized in Fig. \ref{cmp2} and Fig. \ref{cmp1}.
The characteristics of the algorithms are compared with respect to two design criterions. 
In Fig. \ref{cmp1}, the algorithms are compared with regard to QoS measure and the amount of wasted CPU time. The best result according to both criterions was achieved by the evolved heuristic. 
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{images/Qos_wCPU.pdf}
    \caption{A comparison of RLP algorithm and the evolved heuristic considering the QoS measure and the amount of wasted CPU time.}
    \label{cmp1}
\end{figure}

Fig. \ref{cmp2} shows the comparison considering the mean skip factor value and the \textit{Gini} coefficient. 
Although the heuristic yields a greater value of mean skip factor in both examples, its \textit{Gini} coefficient is significantly higher.
The disparity of \textit{Gini} coefficients occurs because the RLP algorithm defines a maximum frequency of skipped or aborted task instances.
It ensures that a predefined number of instances will be completed between the skipped instances, regardless of the task parameters.
On the other hand, the heuristic allows skipping consecutive task instances.
Moreover, the behavior of the heuristic is conditioned by a certain task parameter.
This is emphasized in the described examples, where the heuristic preferred skipping the task with the longest computation time.
% In the task set which was used as a train set for the heuristic (first subplot), the best results regarding both the skip factor and \textit{Gini} coefficient were achieved by the evolved heuristic.
% In the remaining task sets (middle and right subplot), the best results regarding the mean skip factor were accomplished by the evolved heuristic, but the corresponding value of \textit{Gini} coefficient is the greatest. 
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{images/mean_s_stddev.pdf}
    \caption{A comparison of RLP algorithm and the evolved heuristic considering the mean skip factor value and the \textit{Gini} coefficient.}
    \label{cmp2}
\end{figure}

\section{Comparison of Implemented Framework and ECF Framework}
The Evolutionary Computation Framework\footnote{http://ecf.zemris.fer.hr} was used as a referent framework for validating the results of the implemented framework for genetic programming.
The only mandatory input parameter to the ECF framework is the genotype.
It is defined by listing the function and terminal nodes in the configuration file.
Additional parameters stated in the configuration file include the minimum and maximum tree depth, the maximum number of generations and the population size.

To use the ECF for the problem considered in this work, user-defined function and terminal nodes must be defined.
The custom nodes are implemented in separate classes, which inherit the \texttt{Tree::Primitives::Primitive} class.
The classes must implement the \texttt{execute} method:
\begin{lstlisting}[frame=none, label={exec}, caption={A prototype of the \texttt{execute} method.}, captionpos=b]
    void execute(void* result, Tree& tree);
\end{lstlisting}
This method is equivalent to the \texttt{execute} method described in Section \ref{genotype_description}.
In this case, the \texttt{execute} method is used for computing the task priority.
The context needed for computing the priority is passed to the function by the \texttt{result} parameter.
The defined function and terminal nodes are added to the \texttt{Tree} object  describing a genotype through methods \texttt{addFunction} and \texttt{addTerminal}.
The \texttt{addGenotype} method is used for adding the genotype to a \texttt{State} object.
A \texttt{State} object describes a context which contains the genotypes and the algorithm and takes care of the population size, termination condition etc.
In order to use the custom nodes, they must be stated in the configuration file as the \texttt{functionset} and \texttt{terminalset} parameters.

Evaluation of the genotypes is implemented by a user-defined class which inherits the \texttt{EvaluateOp} class.
In this case, the \texttt{TaskEvalOp} class is defined.
The \texttt{evaluate} method invokes the periodic tasks simulator described in Section
\ref{evaluation}.
The simulator is implemented as a template class, so no adjustments were required for using a genotype represented by a different object.
Training is performed on 60 different task sets with utilization factors from the set:
\begin{equation*}
\{ 0.90, 1, 1.1, 1.2, 1.3, 1.4 \}.
\end{equation*}
The mean skip factor of all task sets is set as a fitness value.

Upon the end of the evolution process, ECF creates a file which contains the best individual's genotype in suffix notation.
An example of a genotype evolved by ECF is shown in Fig. \ref{ECF_genotype}.

The evolved genotype was tested on a set of $1500$ different task sets, with utilization factors from the interval $[0.90, 1.60]$.
Fig. \ref{ecf_v_heur} shows the results of testing the evolved genotype, compared to the results achieved by the framework implemented in this work.
The parameters of both frameworks are equivalent and the task sets for testing were generated in the same way.
The presented results of both frameworks were achieved by single-objective optimization, where the mean skip factor is used as the fitness value.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\textwidth]{images/ECF_genotype.pdf}
    \caption{An example of a genotype evolved by the ECF framework.}
    \label{ECF_genotype}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{images/heur_v_ECF.pdf}
    \caption{Results of testing the ECF framework compared to the results achieved by the implemented framework.}
    \label{ecf_v_heur}
\end{figure}

\section{Testing the FreeRTOS Modification}
Modification of the FreeRTOS kernel was tested on a FreeRTOS simulator for Linux systems which uses POSIX threads.
The test application creates multiple tasks with diverse period, duration and weight parameters. 
A code example for a periodic task is given in the following listing.
CPU utilization is simulated by the \verb$count$ variable whose inital value corresponds to the task processing time. 
The variable is decremented at every system tick and when it reaches zero, the \verb$vTaskDealyUntil()$ function is called. 
\begin{lstlisting}[frame=none, label={periodic_task_freertos}, caption={Task function simulating a periodic task.}, captionpos=b]
void TSK_A( void *pvParameters ) {
    TickType_t xLastWakeTimeA;
    const TickType_t xFrequency = PERIOD_A;
    TickType_t count = DURATION_A;

    TickType_t xNextTime;
    TickType_t xTime;
    xLastWakeTimeA = 0;
    
    for(;;) {
        xTime= xTaskGetTickCount();
        //While loop that simulates task duration
        while(count != 0) {
            if((xNextTime = xTaskGetTickCount()) > xTime) {
                count--;
                xTime = xNextTime;
            }
        }
        count = DURATION_A;
        vTaskDelayUntil(&xLastWakeTimeA, xFrequency);
    }
}
\end{lstlisting}
Events of interest - tick increments and context switches are monitored by using trace macros. 
The following trace macros were implemented:
\begin{itemize}
	\item \verb$traceTASK_INCREMENT_TICK( xTickCount )$,
	\item \verb$traceTASK_SWITCHED_IN()$,
	\item \verb$traceTASK_SWITCHED_OUT()$.
\end{itemize}
The \verb$traceTASK_INCREMENT_TICK()$ macro is called during the tick interrupt.
During a context switch, the \verb$traceTASK_SWITCHED_IN()$ macro contains the handle of the task about to enter the running state, while the \verb$traceTASK_SWITCHED_OUT()$ contains the handle of the task about to leave the running state \cite{freertosref}. 

For tracing the total tardiness in overload conditions, a global variable \verb$xTardiness$ is used.
The tardiness value is updated every time a task execution is finished.
\begin{lstlisting}[frame=none, label={tardiness}, caption={Updating the \texttt{xTardiness} variable.}, captionpos=b]
#if( configTRACE_TARDINESS == 1 )
{
	if( pxCurrentTCB->xDeadline < xTickCount )
	{
		xTardiness += ( xTickCount - pxCurrentTCB->xDeadline ) 
			* pxCurrentTCB->xTaskWeight;
	}
}
#endif
\end{lstlisting}

The scheduler was tested on a single task set under overload condition. 
The results will be presented through three examples with different priority calculation heuristics.
The considered task set is given in the following table.
\begin{table}[H]
\begin{center}
\begin{tabular}{|
>{\columncolor[HTML]{FFFFFF}}c |c|c|c|}
\hline
   & \cellcolor[HTML]{FFFFFF}\textbf{$T_i$} & \cellcolor[HTML]{FFFFFF}\textbf{$c_i$} & \cellcolor[HTML]{FFFFFF}\textbf{$w_i$} \\ \hline
\textbf{$\tau_1$} & 8                         & 6                      & 0.5   \\ \hline
\textbf{$\tau_2$} & 5                         & 2                      & 1     \\ \hline
\end{tabular}
\end{center}
\end{table}
The total utilization factor for the given set equals:
\begin{equation*}
\sum_{i=1}^{N}\frac{c_i}{T_i} = \frac{6}{8} + \frac{2}{5} = 1.15.
\end{equation*}

The schedule for the following task set provided by the FreeRTOS default scheduler is shown in figure \ref{freertos_def}.
\begin{figure}[ht]
    \centering
    \includegraphics[width=1\textwidth]{images/freertos_default_1.pdf}
    \caption{A schedule produced by the default FreeRTOS scheduler.}
    \label{freertos_def}
\end{figure}
Both tasks are assigned equal priorities. 
Task $\tau_1$ is the first task to be executed, since it was last added to the ready list. 
The instances of task $\tau_1$ start executing every time task $\tau_1$ is unblocked: $t=8$, $t=16$, $t=24$, $t=32$.
Task $\tau_2$ instances are executed while task $\tau_1$ is in the blocked state, since the activation of task $\tau_2$ is ignored while task $\tau_1$ is executing.
Therefore, every instance of task $\tau_2$ completes after its deadline. 
The total tardiness of task $\tau_2$ equals 44.

If task weight values are taken into account, the task priorities need to be set in a way that a task with a higher weight value has a higher priority.
In this example, task weight values are scaled by 2 in order to get integer priority values.
Fig. \ref{freertos_def_2} shows a schedule produced with task $\tau_2$ priority set to 2 and task $\tau_1$ priority set to 1. 
\begin{figure}[ht]
    \centering
    \includegraphics[width=1\textwidth]{images/freertos_default.pdf}
    \caption{A schedule produced by the default FreeRTOS scheduler with task weights taken into account.}
    \label{freertos_def_2}
\end{figure}
In this example, task $\tau_2$ instances execute as soon as possible because it has a higher priority.
Task $\tau_1$ executes after task $\tau_2$ is switched to blocked state.
Upon the activation of task $\tau_2$, a context switch is performed, giving advantage to task $\tau_2$.
The total weighted tardiness of task $\tau_1$ instances equals 10.

The results of adding priority function to the scheduler will be presented through three examples.
In the first example, the task priority corresponds to the task deadline.
The result is shown in figure \ref{freertos_1}. 
\begin{figure}[ht]
    \centering
    \includegraphics[width=1\textwidth]{images/freertos_edf.pdf}
    \caption{A schedule produced by a modification of FreeRTOS scheduler, heuristic $p_i = d_i$.}
    \label{freertos_edf}
\end{figure}
Higher priority is given to the task instances with earliest deadline.
This heuristic is equivalent to the EDF algorithm.
Total tardiness of task $\tau_1$ is 8, while the $\tau_2$ tardiness equals 6.
The total weighted tardiness for this example equals 10.

In the second example, a heuristic evolved by genetic programming is used as the priority function.
The task's processing time is added to the priority function: $p_i = d_i + c_i$.
The produced schedule is depicted in Fig. \ref{freertos_1}.
\begin{figure}[ht]
    \centering
    \includegraphics[width=1\textwidth]{images/freertos_heur1.pdf}
    \caption{A schedule produced by a modification of FreeRTOS scheduler, heuristic $p_i = d_i + c_i$.}
    \label{freertos_1}
\end{figure}
Priority ties are broken in favor of the task that is already executing.
An example of such situation is time instant $t=15$ where both task $\tau_1$ and $\tau_2$ have the same priority value, $22$.
As total weighted tardiness value is used as a penalty function for heuristics evolution, the produced schedule results in no late instances of the task with greater weight value.
The total tardiness of task $\tau_1$ equals 14, so the total weighed tardiness for this example is 7.

In the last example, a more complex heuristic is used as the priority function.
The task priorities are computed according to the expression:
\begin{align*}
p_i = d_i - SL \cdot \frac{c_i}{w_i}.
\end{align*}
Task priority is proportional to due date, but it takes the positive slack and weight value into account.
Advantage is given to the tasks with earliest due date and gratest positive slack value.
The result is shown in Fig. \ref{freertos_2}.
\begin{figure}[ht]
    \centering
    \includegraphics[width=1\textwidth]{images/freertos_heur2.pdf}
    \caption{A schedule produced by a modification of FreeRTOS scheduler, heuristic $p_i = d_i - SL \cdot c_i / w_i$.}
    \label{freertos_2}
\end{figure}
Again, the task of greater weight value has no late instances.
The total tardiness of task $\tau_1$ equals $16$, thus the total weighted tardiness for this example equals $8$.