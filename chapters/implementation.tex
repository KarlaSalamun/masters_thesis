\chapter{Implementation Overview}
\label{implementation}
The organization of source code including the framework for genetic programming and evaluation interfaces is described by the following table.
\begin{table}[H]
\begin{tabular}{|
>{\columncolor[HTML]{FFFFFF}}l |
>{\columncolor[HTML]{FFFFFF}}l |}
\hline
\texttt{TreeCrossover.h}    & implementation of crossover operator for tree genotypes \\ \hline
\texttt{TreeMutation.h}  & implementation of mutation operator for tree genotypes \\ \hline
\texttt{TreeSelection.h} & implementation of selection operator for tree genotypes  \\ \hline
\texttt{AbstractNode.h} & base class describing the primitives \\ \hline
\texttt{AddNode.h} & implementation of \textit{Add} node functionality \\ \hline
\texttt{ddNode.h} & implementation of \textit{dd} node functionality \\ \hline
\texttt{DivNode.h} & implementation of \textit{Div} node functionality \\ \hline
\texttt{MulNode.h} & implementation of \textit{Mul} node functionality \\ \hline
\texttt{NrNode.h} & implementation of \textit{Nr} node functionality  \\\hline
\texttt{PosNode.h} & implementation of \textit{Pos} node functionality \\ \hline
\texttt{ptNode.h} & implementation of \textit{pt} node functionality \\ \hline
\texttt{SDNode.h} & implementation of \textit{SD} node functionality \\ \hline
\texttt{SLNode.h} & implementation of \textit{SL} node functionality \\ \hline
\texttt{SPrNode.h} & implementation of \textit{SPr} node functionality \\ \hline
\texttt{SubNode.h} & implementation of \textit{Sub} node functionality \\ \hline
\texttt{WNode.h} & implementation of \textit{W} node functionality \\ \hline
\texttt{TreeSolution.h} & a class describing a population member \\ \hline
\texttt{TreeConstructor.h} & interface for creating tree genotypes \\ \hline
\texttt{TreePopulation.h} & interface for creating the population \\ \hline
\texttt{GeneticAlgorithm.h} & interface for heuristic evolution (single-objective) \\ \hline
\texttt{NSGA.h} & interface for heuristic evolution (multi-objective) \\ \hline
\texttt{GPEvaluateHeuristic.h} & interface for heuristic evaluation \\ \hline
\texttt{Simulator.h} & implementation of periodic tasks simulator \\ \hline
\texttt{Scheduler.h} & scheduler implementation \\ \hline
\texttt{Task.h} & a class describing periodic tasks \\ \hline
\texttt{UunifastCreator.h} & interface for generating tasks by \textit{UUniFast} algorithm \\ \hline
\end{tabular}
\end{table}

\section{Generating Test Task Sets}
For testing the performance of the considered algorithms and heuristics, it is needed to generate a large amount of syntetic test tasks.
The simulation results should not be biased by the task generation method, so selecting the approach to random generation of the task set requires special attention.
An important factor in generating syntetic task sets is the probability density function of the random variables used to generate the task set parameters \cite{bini2005measuring}.

The first step to generating the task set parameters is generating the task periods.
Treating the task periods as random variables does not reflect the characteristics of real applications, since task periods are defined by the user and enforced by the operating system \cite{bini2005measuring}.
However, for testing the scheduling heuristics without any a priori knowledge about their future applications and the characteristics of the corresponding environment, assuming task periods as random variables with an uniform distribution is acceptable.

After selecting the task periods, it is required to generate task computation times, according to a given distribution.
The computation time $c_i$ is assumed to have a uniform distribution scaled by a factor $T_i$:
\begin{equation*}
c_i \sim \mathcal{U}[0, T_i].
\end{equation*}
This is equivalent to assuming each task utilization $u_i$ to have a uniform distribution in the interval $[0, 1]$.

For testing purposes, it is often desireable to generate the task utilization values in a way that they correspond to the given total processor utilization value.
The stated feature is accomplished by generating the individual utilization $u_i$ with an uniform distribution in the interval $[0, \overline{U}]$, subject to the constraint:
\begin{equation*}
\sum_{i=1}^{N}u_i = \overline{U}.
\end{equation*}
The utilization disparity in a task set can be expressed by a parameter called \textit{U-difference}:
\begin{equation*}
\delta = \frac{max_i\{u_i\}-min_i\{u_i\}}{\sum_{i=1}^{n}u_i}.
\end{equation*}
If $\delta = 0$, all utilization factors are the same, whereas $\delta=1$ denotes the maximum degree of difference \cite{bini2005measuring}.

To efficiently generate utilization factors for the task set with given utilization factor $\overline{u}$, where $\delta \rightarrow 1$, the \textit{Uunifast} algorithm is used.

\subsection{UUniFast Algorithm}
The UUniFast algorithm is built on the consideration that the probability density function of the sum of independent random variables is given by the convolution of their probability dension functions \cite{bini2005measuring}.
In every algorithm iteration, a value which represents a sum of $n-1$ variables is randomly generated.
A single utilization factor $u_i$ is set equal to the difference between $\overline{u}$ and the generated value.
This is repeated for each task and the complexity of the algorithm is $O(n)$.
A pseudocode describing the algorithm is shown in Alg. \ref{uunifast}.
The algorithm inputs are the number of variables \texttt{n} and mean utilization factor, \texttt{mean\_u}.
\begin{algorithm}
\caption{Uunifast algorithm.\label{uunifast}}
\begin{algorithmic}[1]
\State sum\_u = mean\_u
\For{i=1 \;\To \; n-1}
\State next\_sum\_u = sum\_u * rand \^{} (1/(n-i))
\State vec\_u[i] = sum\_u - next\_sum\_u
\State sum\_u = next\_sum\_u
\EndFor
\State vec\_u[n] = sum\_u
\end{algorithmic}
\end{algorithm}
Figure \ref{uunifast:fig} illustrates the values of 10000 utilization tuples generated by the UUniFast algorithm.
The value of \texttt{n} is set to 3, while the mean utilization factor $\overline{u}$ is set to 1.
The density of the generated values is uniform in the interval $[0, 1]$.
\begin{figure}[ht]
    \centering
    \includegraphics[width=1\textwidth]{images/rsz_uunifast.png}
    \caption{Utilization tuples generated by the UUniFast algorithm.}
    \label{uunifast:fig}
\end{figure}

The generation of the test sets of periodic tasks is implemented in the 
\\\texttt{UunifastCreator} class by the \texttt{create\_test\_set()} method.
The required number of tasks and the overload factor are set through the class constructor.
First, the task utilizations are created by the \texttt{generate\_utils()} method which implements the algorithm described in Alg. \ref{uunifast}.
The task periods are generated as random variables with logarithmic uniform distribution.
This is implemented in the \texttt{generate\_log\_uniform()} method.
Task computation times are computed by multiplying the utilization factor and the corresponding period.

\section{Heuristics Evolution}
The algorithm for genetic programming is implemented in the \texttt{GeneticAlgorithm} class.
The population size and generation number parameters are set through the class constructor.
Each individual is represented as an object of class \texttt{TreeSolution}.
This class contains two variable members: the fitness value of the individual and a pointer to the tree genotype.

\subsection{Genotype Description}
\label{genotype_description}
The priority functions evolved by genetic programming are represented in the form of a tree.
The tree genotypes correspond to arithmetic expressions used to calculate the priority of each job.
As described in the second chapter, a tree genotype consists of function and terminal nodes.
The terminal nodes used for assembling a priority function are listed in the following table.
\begin{table}[]
\centering
\begin{tabular}{|
>{\columncolor[HTML]{EFEFEF}}c |
>{\columncolor[HTML]{FFFFFF}}l |}
\hline
\textbf{Terminal name} & \multicolumn{1}{c|}{\cellcolor[HTML]{EFEFEF}\textbf{Definition}} \\ \hline
pt                     & nominal computation time of a job ($p\_j$)                          \\ \hline
dd                     & due date ($d\_j$)                                                  \\ \hline
w                      & weight ($w\_j$)                                                    \\ \hline
SL                     & positive slack, $SL = max\{d\_j - p\_j - time, 0\}$                \\ \hline
Nr                     & number of remaining (unscheduled) jobs                           \\ \hline
SPr                    & sum of computation times of all remaining jobs                    \\ \hline
SD                     & sum of due dates of all jobs                                     \\ \hline
\end{tabular}
\end{table}
The values of the variables in terminal node set depend not only on the parameters of the current job that is being dispatched, but also on the parameters of remaining (unscheduled) jobs.

The following table contains a list of the function nodes.
\begin{table}[H]
\centering
\label{tbl:functions}
\begin{tabular}{|
>{\columncolor[HTML]{EFEFEF}}c |
>{\columncolor[HTML]{FFFFFF}}c |}
\hline
\textbf{Function name} & \cellcolor[HTML]{EFEFEF}\textbf{Definition}                  \\ \hline
ADD, SUB, MUL, DIV     & Addition, subtraction, multiplication and protected division \\ \hline
POS                    & $POS(a) = max\{a, 0\}$                                         \\ \hline
\end{tabular}
\end{table}
Protected division node is a modified division operator which checks whether the second argument (denominator) is zero before performing division.
If the second argument is zero, it returns the value 1, regardless of the value of the first argument.

The genotype primitives are described by objects of the base class \texttt{AbstractNode}.
Child nodes of each primitive are stored as a vector of pointers to \texttt{AbstractNode} objects.
% The \texttt{children} vector is a member of the \texttt{AbstractNode} class.
Parameters and actions for specific primitives are handled by the derived classes, where every class corresponds to a function or terminal node.
Each class contains an \texttt{execute()} method which recursively invokes the same method upon every child node.
In terminal nodes, the \texttt{execute()} method returns the value of the corresponding task parameter.

Generating the tree genotypes is handled by the methods of the \texttt{TreeConstructor} class.
There are two basic approaches for generating a genotype: the \textit{full} method and the \textit{grow} method \cite{koza1992genetic}.
The \textit{full} method is used for generating full trees. 
It sets the root node as a random function or terminal node.
If root is a function node, the root's children nodes are set to random function nodes.
The procedure is the same for every node until the required depth is reached.
The nodes at final depth are set to random terminal nodes.
On the other hand, the \textit{grow} method selects any node (function or terminal) in each step.
Both approaches are implemented as methods of the \texttt{TreeConstructor} class and their prototypes are stated in Code listing \ref{treeconstr}.
\begin{lstlisting}[frame=none, label={treeconstr}, caption={Functions for implementing the \textit{full} and \textit{grow} methods for creating a genotype.}, captionpos=b]
void construct_tree_full( int max_depth, AbstractNode *&root );
void construct_tree_grow( int max_depth, AbstractNode *&root );
\end{lstlisting}
The \texttt{max\_depth} argument determines the maximum depth of the tree.
Actual depth has a random value in the interval $[1, \texttt{max\_depth}]$.
The trees are constructed using the BFS (breadth-first search) algorithm.
Figure \ref{fullgrow} depicts the difference between the trees generated by \textit{full} and \textit{grow} methods.
\begin{figure}[ht]
    \centering
    \includegraphics[width=1\textwidth]{images/fullgrow.pdf}
    \caption{Examples of genotypes generated by the \textit{full} (left) and \textit{grow} method (right).}
    \label{fullgrow}
\end{figure}

\subsection{Operators}
Selection, crossover and mutation operators are implemented in the \\\texttt{SelectionOperator}, \texttt{CrossoverOperator} and \texttt{MutationOperator} class, respectively.
Selection is performed by the \texttt{get\_members} method whose prototype is stated in Code listing \ref{selection}.
\begin{lstlisting}[frame=none, label={selection}, caption={Prototype of the \texttt{get\_members} method which performs selection.}, captionpos=b]
template <typename T>
void TreeSelection<T>::get_members( std::vector<T> &population, 
	std::vector<T> &members );
\end{lstlisting}
The selected individuals are stored in the \texttt{members} vector.

Crossover operator is implemented by the \texttt{get\_children} method whose prototype is stated in Code listing \ref{crossover}.
\begin{lstlisting}[frame=none, label={crossover}, caption={Prototype of the \texttt{get\_children} method which performs crossover.}, captionpos=b]
template <typename T>
void TreeCrossover<T>::get_children( std::vector<T> &parents, 
	std::vector<T> &children );
\end{lstlisting}
Crossover is performed by selecting a random subtree of every parent genotype.
This is done by invoking the \texttt{pick\_random} method implemented in \texttt{AbstractNode} class which returns a pointer to a random child node at a random depth.
The child genotypes are generated by swapping the randomly selected subtrees.
If this operation would cause the tree depth to exceed the maximum tree depth, crossover is not performed.

Mutation of a genotype is done through the \texttt{mutate\_solution} method.
Prototype of this method is stated in Code listing \ref{mutation}.
\begin{lstlisting}[frame=none, label={mutation}, caption={Prototype of the \texttt{mutate\_solution} method.}, captionpos=b]
template <typename T>
void TreeMutation<T>::mutate_solution ( T &solution );
\end{lstlisting}
The first step of the \texttt{mutate\_solution} method is generating a new subtree which shall replace a randomly selected subtree of the individual.
The new subtree is generated by invoking either the \texttt{construct\_tree\_full} or the \texttt{construct\_tree\_grow} method with equal probability.
The subtree replacement is performed by the \texttt{replace\_random} method implemented in the \texttt{AbstractNode} class.
This method takes a pointer to a newly created subtree and replaces a random child at a random depth with the subtree.

\section{Heuristics Evaluation}
\label{evaluation}
Evaluation of all the individuals in the population is performed in each generation.
In this work, the fitness function corresponds to the mean skip factor of all tasks.
To achieve a schedule with a maximum number of consecutive completed tasks (with minumum number of skipped tasks), the fitness function must be maximized.

A method in charge of evaluating an individual and returning its fitness value is the \texttt{get\_value} method, implemented in the \texttt{GPEvaluateHeuristic} class.
This method generates an arbitrary number of training task sets and sets the individual's genotype as the priority function.
The individual is evaluated by running a simulation of training tasks execution and scheduling the tasks according to the individual's genotype.
Simulation time is set equal to the hyperperiod corresponding to the training task set.
The number of skipped instances is tracked for each task.
The fitness value is computed by calculating the mean skip factor of each task and scaling it by the total number of tasks.

\subsection{Periodic Tasks Simulator}
In this work, the tasks are represented as objects of class \texttt{Task}.
The following parameters are set through the constructor:
\begin{itemize}
	\item task period,
	\item duration,
	\item relative due date,
	\item weight,
	\item skip factor,
	\item task ID.
\end{itemize}
The task priority computed by the heuristic is stored in the \texttt{priority} member variable.
Additional parameters used for tracking and managing task execution include:
\begin{itemize}
	\item instance counter,
	\item arrival time,
	\item absolute due date,
	\item state,
	\item tardiness.
\end{itemize}
When a new task is created, these parameters are initialized by the \texttt{initialize\_task()} method.
The \texttt{instance\_counter} variable is used for tracking which instance of a task is active and computing the arrival time of the next instance.
Upon the appearance of a new task, its absolute due date and state parameters are updated.
The state parameter is used in skip-over task model and it is represented by a variable of enumerated type. Its initial value is set to \texttt{RED}.
The states of the following instances are set by the \texttt{update\_rb\_params()} method.
If the skipover model is not being used, the task tardiness is tracked.
The tardiness value of a task is updated upon the end of the task execution through the \texttt{update\_tardiness()} method.

At the beginning of the simulation, the tasks are initialized and stored in the \texttt{pending} vector.
The \texttt{running} variable which stores the task in the running state is set to \texttt{NULL}.
The \texttt{pending} vector is iterated to check whether a task is ready for execution.
This is done by the \texttt{isReady} method which compares the task activation time with current simulation time.
If a task is ready, it is placed in the \texttt{ready} vector.
The priorities of the ready tasks are computed by running the \texttt{execute()} method on the evaluated genotype.
The context needed by the \texttt{execute()} method includes the object which describes the current task, a vector of pending tasks and a vector of processed tasks.
The object and vectors are stored in the \texttt{task\_ctx} structure and passed to the \texttt{execute()} method by a void pointer.
The computed priority is stored in the \texttt{priority} member variable of the \texttt{Task} object.

The scheduler is invoked at every time instance when the \texttt{ready} list is not empty and it assigns the highest priority task to the \texttt{running} variable.
Function which performs dispatching is implemented in a separate class and its complete source code is shown in Code listing \ref{sched1}.
\begin{lstlisting}[frame=none, label={sched1}, caption={The \texttt{schedule\_next} method.}, captionpos=b]
void Scheduler::schedule_next( std::vector<Task *> &ready, 
	Task *&running )
{
    std::sort( ready.begin(), ready.end(),
        []( const Task *a, const Task *b ) -> 
            bool{ return a->get_priority() < b->get_priority();});

    if( running ) {
        if ( preempt( ready[0], running ) ) {
            running->isPreempted = true;
            std::swap( ready[0], running );
        }
    }
    else {
        running = std::move( ready[0] );
        ready.erase( ready.begin() );
    }
}
\end{lstlisting}
The tasks in the \texttt{ready} vector are sorted with respect to their priority value in increasing order, thus the task at the beginning of the list needs to be executed first.
If a task is already running, it is needed to check whether the ready task has a higher priority.
This is done by the \texttt{preempt} function which returns \texttt{true} if the ready task of highest priority shall preempt the running task.

When a running task is completed,
its instance counter is updated, as well as the absolute due date and state parameters.
As described in the third chapter, the next state of a successfully completed task is set to 
\texttt{BLUE}.
The skip factor of the task is incremented.
The task is inserted into the \texttt{pending} vector and \texttt{running} variable is set to \texttt{NULL}.
If the running task reaches its due date and it is not completed, the task is aborted and its next instance state is set to \texttt{RED}.
The current skip factor of the task is stored in a vector and its new value is set to $0$.
The task is then stored to the \texttt{pending} vector.

In every time slice, the deadlines of the tasks in the \texttt{ready} vector are checked.
If a task has reached its deadline, its current instance is skipped and the next instance state is set to \texttt{RED}.
The skip factor of a skipped ready task is dealt with in the same way as the skip factor of the aborted running task.

The operation of the periodic tasks simulator is shown by a pseudocode in Alg. \ref{simulator}.
\begin{algorithm}
\caption{Periodic tasks simulator.\label{simulator}}
\begin{algorithmic}[1]
\State initialize tasks in $pending$ list
\State $running = \emptyset$
\State $current\_time = 0$
\While{$current\_time < simulation\_time$}
	\ForAll{tasks in $pending$}
		\If{task is ready}
			\State $ready.append(task)$
		\EndIf
	\EndFor
	\ForAll{tasks in $ready$}
		\State compute task priority
	\EndFor
	\State schedule task with highest priority
	\If{$running \neq \emptyset$}
		\If{$running$ is finished}
			\State increment $running$ instance counter
			\State update $running$ parameters
			\State increment $running$ skip factor
			\State $pending.append(running)$
			\State $running = \emptyset$
		\Else 
			\If{$running$ missed deadline}
				\State reset $running$ skip factor to $0$
				\State $pending.append(running)$
				\State $running = \emptyset$ 
			\EndIf
		\EndIf
	\EndIf
	\ForAll{tasks in $ready$}
		\If{task missed deadline}
			\State reset $running$ skip factor to $0$
			\State $pending.append(task)$
			\State $ready.erase(task)$
		\EndIf
	\EndFor
	\State $current\_time+=1$
\EndWhile
\end{algorithmic}
\end{algorithm}

\section{Support for Multicriterial Optimization and Cooperative Coevolution}
\subsection{Multicriterial Optimization}
The approach described in previous sections is a single-objective optimization problem with the goal of maximizing the mean skip factor of the given task set.
The problem with this approach is that the produced schedules have a tendency to skip the tasks with longest periods more frequently.
The skip factors of such tasks approach zero.
As tasks with longer periods appear in fewer instances, their skip factors have a negligible impact on the overall mean skip factor value used as the fitness function.
On the other hand, by skipping tasks with longer periods, the execution of tasks with shorter periods is stimulated, which significantly increases the mean skip factor value.
A schedule with unevenly distributed skip factors is not acceptable.
To generate schedules where task skip factors are evenly distributed, a second optimization criterion must be included.

The second criterion punishes the heuristics that generated schedules with large deviation between skip factors of the tasks.
The goal is to minimize the deviation between the task skip factors.
As a measure of the deviation between the skip factors, the Gini coefficient is used\footnote{The Gini coefficient is used for measuring the inequality among values of a frequency distribution. A Gini coefficient of zero expresses that all values are the same, whereas a Gini coefficient of one expresses maximal inequality \cite{gini1912variabilita}.}.
For a set of $n$ tasks with skip factors $s_i$, the Gini coefficient is computed by the following expression:
\begin{equation*}
G = \frac{\sum_{i=1}^{n}\sum_{j=1}^{n}|s_i - s_j|}{2n^2\overline{s}}.
\end{equation*}

Optimization of the two objectives is implemented according to the NSGA-II algorithm.
The \texttt{get\_value} method is expanded in a way that the return value is a pair of two fitness values: mean skip factor and \textit{Gini} coefficient.
% The values of the \textit{Gini} coefficient are from the interval $[0, 1]$, while the mean skip factor can has no upper bound to its value.
% Therefore, when computing the fitness value corresponding to the mean skip factor, it is scaled in order to keep the value in the interval $[0, 1]$.
The fitness values are stored in the member variable \texttt{fitness\_NSGA} of type \texttt{std::pair} in the \texttt{TreeSolution} class.
Since the second objective, Gini coefficient, is a minimization problem, the first objective must also be reduced to minimization.
This is achieved by assigning the negative value of the skip factor as the fitness value of the first objective.
The NSGA-II algorithm is implemented by the \texttt{get\_solution} method of the \texttt{NSGA} class.
Non-dominated sorting and grouping sort are implemented by separate methods.

Fig. \ref{single_vs_multi} shows the results of testing the NSGA-II algorithm.
The algorithm was tested on a population of size $20$ with $50$ generations.
The subplot on the left shows Pareto-optimal solutions of the final generation with respect to the \textit{Gini} coefficient ($x$-axis) and the scaled mean skip factor ($y$-axis.)
The right subplot shows the results of testing the final solution of single-objective optimization on $1500$ different task sets.
\begin{figure}[ht]
    \centering
    \includegraphics[width=1\textwidth]{images/single_vs_multi.pdf}
    \caption{Pareto-optimal solutions as a result of multi-criterial optimization (left subplot) and the result of single-objective optimization (right subplot). }
    \label{single_vs_multi}
\end{figure}

\subsection{Cooperative Coevolution}
The idea of using cooperative coevolution in solving the considered scheduling problem is to add another independent population whose genotypes represent acceptance tests for new tasks.
In that way, the heuristic for computing the task priorities and the heuristic for performing acceptance tests are evolved separately.
The genotype nodes are of the same type in both populations.

Using the acceptance tests is useful for solving the problem of aborted tasks.
When a running task reaches its due date and it is not completed, the task is aborted and the time interval
in which it was executed is wasted.
The goal is to evolve an acceptance test which rejects the tasks that cannot be completed by their due date, so they don't waste any CPU time.

To implement coevolution, the \texttt{TreeSolution} class is modified in a way that it contains two genotypes - the first genotype represents the heuristic used for priority calculation, while the second genotype corresponds to the acceptance test. 
The evolution operators (selection, crossover and mutation) are performed separately on the two genotypes.
Collaboration between the two genotypes is formed when the individual is being evaluated.

The acceptance test is integrated in the periodic tasks simulator.
After the activation of a new task instance is detected, the acceptance test heuristic is executed.
If the computed value is greater than zero, the task is accepted and placed into the \texttt{ready} vector.
Otherwise, the task is automatically skipped. 
Its skip factor is reset and the task is placed in the \texttt{pending} vector.
The priority computation by the other genotype is performed upon the accepted tasks.

\section{Integrating Evolved Scheduling Heuristics into FreeRTOS}
\subsection{FreeRTOS Task Management}
FreeRTOS is an open-source real-time operating system designed for embedded systems. 
Its main features include portability, simplicity of the source code, and binary code compactness. 

The minimum FreeRTOS kernel code is contained in three source files \cite{brown2012architecture}. 
The code that handles task creating and scheduling is situated in the source file \verb$tasks.c$ and header file \verb$task.h$.

The tasks are managed through the Task Control Block (TCB) structure. 
A TCB corresponding to each task contains all information necessary to completely describe the task state. 
The TCB fields include task name, initial priority, unique TCB number and a pointer to the top of the task's stack. 
When a task is added to a list, it is represented by a pointer to a \verb$ListItem$ object. 
The TCB structure contains two \verb$ListItem$ objects: \verb$xStateListItem$ and \verb$xGenericListItem$.

A task in FreeRTOS can exist in one of the following states: deleted, suspended, ready, blocked and running. 
Figure \ref{freertos:state} shows a state diagram for FreeRTOS tasks. 

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.70\textwidth]{images/freertos_fsm.pdf}
    \caption{State diagram of FreeRTOS tasks.}
    \label{freertos:state}
\end{figure}

Task states are tracked implicitly by placing tasks in the appropriate lists: ready list, suspended list, etc. As a task changes state, it is simply moved from one list to another 
\cite{brown2012architecture}.

A task is created by the \verb$xTaskCreate()$ function. 
The user-defined parameters required to create a task include: 
\begin{itemize}
	\item a pointer to the function that implements the task,
	\item the task name,
	\item the depth of the task's stack,
	\item the task's priority,
	\item a pointer to any parameters needed by the task function.
\end{itemize}
The \verb$xTakCreate()$ first allocates memory for the task's TCB and stack.
Next, the TCB fields are initialized with the task name, priority and stack depth from function parameters. 
Finally, a pointer to the top of the task's stack is initialized and the stack is populated with a \textit{dummy frame}. 
In that way, the task is prepared for its first context switch \cite{goyette2007analysis}.

After all the required tasks have been created, the FreeRTOS scheduler is started by a call to the 
\verb$vTaskStartScheduler()$ function. 
First, the Idle task with the lowest priority is created.
The global timer \verb$xTickCount$ is set to zero. 
The \verb$vTaskStartScheduler()$ function then passes control to the \verb$xTaskStartScheduler()$ in the Hardware Abstraction Layer (HAL), which configures the timer interrupt needed for invoking the scheduler. 
The HAL scheduler is also in charge of restoring the context of the currently selected task
\cite{goyette2007analysis}. 

Newly created tasks are placed into the ready state and added to the ready list. 
The ready list is implemented as an array of task lists:
\begin{lstlisting}[frame=none, label={lst:readylist}, caption={Ready task list}, captionpos=b]
static List_t pxReadyTasksLists[configMAX_PRIORITIES];
\end{lstlisting}
The elements of the \verb$pxReadyTasksLists$ array are lists of tasks that have the same priority, from \verb$0$ to \verb$configMAX_PRIORITIES-1$.
An example of a ready list is shown in figure \ref{freertos:ready}.
There are three priority levels in the list: task A has priority 0, no tasks have priority 1 and tasks B, C and D have priority 2. 

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.70\textwidth]{images/ready_list.pdf}
    \caption{A schematic view of the FreeRTOS Ready List. Modified from \cite{brown2012architecture}.}
    \label{freertos:ready}
\end{figure}
When a new task is added to the ready list, its \verb$xStateListItem$ is inserted at the end of the 
associated priority level list.

A task in the running state is identified by the \verb$pxCurrentTCB$ variable, which is updated at every system tick interrupt. 
Every time the tick interrupt occurs, the \verb$xTaskSwitchContext()$ function is called and it selects the highest-priority ready task.
After the highest priority level is determined,
the highest-priority task is selected by the \verb$listGET_OWNER_OF_NEXT_ENTRY()$ function.
The function traverses the priority level's ready list and assigns the next ready task to the \verb$pxCurrentTCB$ variable.

The tasks enter the blocked state when they are waiting for time related or synchronization events. 
A task can be placed into the blocked state by calling the \verb$vTaskDelay()$ and \verb$vTaskDelayUntil()$ API functions. 
The \verb$vTaskDelayUntil()$ function defines the frequency at which the task is periodically executed and therefore it can be used to implement periodic tasks \cite{carraro2016implementation}.
The function sets the value of the tick at which the task will activate into the \verb$xStateListItem$ element and places it in the delayed list:
\begin{lstlisting}[frame=none, label={lst:delay}, caption={Transition to blocked state.}, captionpos=b]
listSET_LIST_ITEM_VALUE(&(pxCurrentTCB->xStateListItem), 
						xTimeToWake);
vListInsert(pxDelayedTaskList, &(pxCurrentTCB->xStateListItem));
\end{lstlisting}
The \verb$vListInsert()$ function sorts the elements by the \verb$xStateListItem$ values. 
At every increment of the tick count, it must be checked whether a task needs to be unblocked. 
This is implemented in the \verb$xTaskIncrementTick()$ function which is called from the HAL every time the timer interrupt occurs.
The nearest unblock tick value is stored in the \verb$xNextUnblockTime$ variable, and it corresponds to the unblock time of the first element of the delayed list.
When the current tick value achieves the \verb$xNextUnblockTime$ value, the first task from the delayed list is retrieved by the \verb$listGET_OWNER_OF_HEAD_ENTRY()$ function.
The task is placed in the ready list and the function return value signifies that a context switch is needed.

The suspended state is assumed when the \verb$vTaskSuspend()$ API function is called and the tasks are switched back from suspended state by \verb$vTaskResume()$ function.

\subsection{FreeRTOS Scheduler Modification}
FreeRTOS uses a static priority policy for task scheduling. 
To achieve dynamic priority assignment, the FreeRTOS task management subsystem must be modified. 
This is possible by modifying the existing FreeRTOS functions and data structures, but also adding new objects that allow dynamic task priorities to be managed. 

The general idea of implementing a dynamic scheduler is to create a new ready list which contains tasks ordered by a custom parameter defined in \verb$xTaskStateItem$ object.
In this case, \verb$xTaskStateItem$ shall contain the task priority computed by the evaluated heuristic and the list will be sorted in increasing priority value. 
The priority of the Idle task is set to some arbitrary value, significantly greater than the other tasks' priorities. 

To determine whether dynamic scheduling based on the evolved heuristic is used, a configuration variable \verb$configUSE_GP_SCHEDULER$ is added to the \verb$FreeRTOSConfig.h$ file. 

As described in the previous sections, the task parameters used for priority computation include the task period, duration, deadline and weight. 
These parameters need to be added to the TCB structure. 
Additionally, the task priority value computed by the heuristic is added, as well as the \verb$xRemainingTicks$ variable used for tracing task execution.
\begin{lstlisting}[frame=none, label={TCB}, caption={Modification of the TCB.}, captionpos=b]
typedef struct tskTaskControlBlock
{
	...
	#if( configUSE_GP_SCHEDULER == 1 )
		TickType_t xTaskPeriod;
		TickType_t xTaskDuration;
		TickType_t xDeadline;
		TickType_t xRemainingTicks;
		double xTaskWeight;
		double xPriorityValue;
	#endif
} tskTCB;
\end{lstlisting}
The additional parameters are set through the \verb$xTaskPeriodicCreate()$ function, which is a modified version of the standard \verb$xTaskCreate()$.
\begin{lstlisting}[frame=none, label={periodicCreate}, caption={The \texttt{xTaskPeriodicCreate()} function prototype.}, captionpos=b]
BaseType_t xTaskPeriodicCreate(	TaskFunction_t pxTaskCode,
						const char * const pcName,		
						const configSTACK_DEPTH_TYPE usStackDepth,
						void * const pvParameters,
						UBaseType_t uxPriority,
						TaskHandle_t * const pxCreatedTask,
						TickType_t period,
						TickType_t duration,
						uint32_t weight ) PRIVILEGED_FUNCTION
\end{lstlisting}
The user-defined parameters are added to the new task's TCB structure. 
\begin{lstlisting}[frame=none, label={TCB_params}, caption={Adding the user-defined task parameters to the TCB structure.}, captionpos=b]
pxNewTCB->xTaskPeriod = period;
pxNewTCB->xTaskDuration = duration;
pxNewTCB->uTaskWeight = weight;
pxNewTCB->xDeadline= period;
pxNewTCB->xRemainingTicks = duration;
\end{lstlisting}
After the task priority value is computed, this value is assigned to the task's \\\verb$xStateListItem$ element. 
\begin{lstlisting}[frame=none, label={init_priority}, caption={Assigning the task priority to the \texttt{xStateListItem} element.}, captionpos=b]
vTaskComputePriority( pxNewTCB );
listSET_LIST_ITEM_VALUE( &((pxNewTCB)->xStateListItem), 
						(pxNewTCB)->xPriorityValue );
\end{lstlisting}
Next, the new ready tasks list must be declared.
\begin{lstlisting}[frame=none, label={ready_list}, caption={Declaration of the new ready tasks list.}, captionpos=b]
#if( configUSE_GP_SCHEDULER == 1 )
	PRIVILEGED_DATA static List_t xReadyTasksListGP;
#endif /* configUSE_GP_SCHEDULER */
\end{lstlisting}
Before adding a task to the ready list, its priority value is computed. 
Since the Idle task is added to the ready list in the same way as other tasks, it has to be distinguished in some manner. 
While creating the Idle task, its duration is set to 0.
Therefore, before assigning a priority value to a task, its duration value is checked. 
An example of the priority computation according to an arbitrary heuristic is given in Code listing \ref{priority_comp}. 
In this example, priority is computed according to the expression:
\begin{align*}
p_i = d_i + c_i + max\{ d_i - c_i - current\_time, 0 \}.
\end{align*}
The Idle task priority is set to 1000.
\begin{lstlisting}[frame=none, label={priority_comp}, caption={Macro function for priority computation.}, captionpos=b]
#define vTaskComputePriority( pxTCB )
{
	pxTCB->xPriorityValue = ( pxTCB->xTaskDuration != 0 ) ? 
		( pxTCB->xDeadline + pxTCB->xTaskDuration + 
		max( pxTCB->xDeadline - pxTCB->xTaskDuration, 0 )) : 1000;
}	
\end{lstlisting}
The \verb$prvAddTaskToReadyList()$ function is modified in a way that the \verb$vListInsert()$ method is used instead of \verb$vListInsertEnd()$. 
The elements are sorted by the \\\verb$xStateListItem$ element, so the lowest priority tasks are placed at the beginning of the list. 
\begin{lstlisting}[frame=none, label={ready_add}, caption={Adding a new task to the ready list.}, captionpos=b]
#if ( configUSE_GP_SCHEDULER == 1 )
	#define prvAddTaskToReadyList( pxTCB )
	{
		vTaskComputePriority( pxTCB );
		listSET_LIST_ITEM_VALUE( &((pxTCB)->xStateListItem), 
								(pxTCB)->xPriorityValue );
		vListInsert(&(xReadyTasksListGP), 
					&((pxTCB)->xStateListItem) );
	}																								
#else 																								
	#define prvAddTaskToReadyList( pxTCB )
	{
		vListInsertEnd(&(pxReadyTasksLists[(pxTCB)->uxPriority] ), 
						&((pxTCB)->xStateListItem));
	}
#endif
\end{lstlisting}
The \verb$prvInitialiseTaskLists()$ must be called in order to initialise the elements of the ready tasks list.
\begin{lstlisting}[frame=none, label={init_lists}, caption={Initialization of the tasks in the \texttt{ready} list.}, captionpos=b]
#if( configUSE_GP_SCHEDULER == 1 )
	vListInitialise( &(xReadyTasksListGP) );
#endif /* configUSE_GP_SCHEDULER */
\end{lstlisting}
When a new task is added to the ready list while the scheduler is not running, its priority value is compared to the priority of the running task. 
If the new task has a higher priority, it is set as the currently running task.
Therefore, a modification in the \verb$prvAddNewTaskToReadyList()$ function is required in order to include the comparison between computed priority values. 
\begin{lstlisting}[frame=none, label={newtask}, caption={Modification of the \texttt{prvAddNewTaskToReadyList()} function.}, captionpos=b]
#if( configUSE_GP_SCHEDULER == 1 )
	vListInitialise( &(xReadyTasksListGP) );
#endif /* configUSE_GP_SCHEDULER */
\end{lstlisting}
The \verb$vTaskStartScheduler()$ is also modified in order to manage the creation of the Idle task.
\begin{lstlisting}[frame=none, label={idle}, caption={Creation of the Idle task.}, captionpos=b]
#if( configUSE_GP_SCHEDULER == 1 )
{
	xReturn = xTaskPeriodicCreate( prvIdleTask,
					configIDLE_TASK_NAME,
					configMINIMAL_STACK_SIZE,
					( void* ) NULL,
					( tskIDLE_PRIORITY | portPRIVILEGE_BIT ),
					&xIdleTaskHandle,
					0,
					0,
					0 );
}
#else 
	...
\end{lstlisting}
The \verb$vTaskSwitchContext()$ function is modified in a way that it selects the first element of the ready list as the currently running task, instead of calling the \\\verb$taskSELECT_HIGHEST_PRIORITY_TASK()$ function.
\begin{lstlisting}[frame=none, label={switchcontext}, caption={\texttt{vTaskSwitchContext()} modification.}, captionpos=b]
#if( configUSE_GP_SCHEDULER == 1 )
{
	pxCurrentTCB =
		(TCB_t *)listGET_OWNER_OF_HEAD_ENTRY(&(xReadyTasksListGP));
}
#else 
{
	taskSELECT_HIGHEST_PRIORITY_TASK();
}
#endif
\end{lstlisting} 
Since absolute deadline value is required for priority computation, this parameter must be updated at each end of a task instance.
If the \verb$xRemainingTicks$ variable reached zero before the task is switched out, \verb$xDeadline$ parameter is updated.
\begin{lstlisting}[frame=none, label={taskfinish}, caption={\texttt{Updating the \texttt{xDeadline} parameter at the end of task instance}.}, captionpos=b]
#if( configUSE_GP_SCHEDULER == 1 )
{
	if( pxCurrentTCB->xRemainingTicks == 0 ) 
	{
		pxCurrentTCB->xRemainingTicks = 
			pxCurrentTCB->xTaskDuration;
		pxCurrentTCB->xDueDate += pxCurrentTCB->xTaskPeriod;
	}
}
#endif
\end{lstlisting}
Finally, the last modifications are applied to the \verb$xTaskIncrementTick()$ function. 
The previous subsection described how a task is unblocked and placed into the ready list.
When a task is blocked, its \verb$xStateListItem$ element refers to the unblock tick value. 
Therefore, before placing an unblocked task into the ready list, its \verb$xStateListItem$ element must be assigned to the priority value.
Priority of the unblocked task is compared to the running task's priority in order to determine whether a context switch is needed.
Hence, the priority of the task in running state is also updated.
\begin{lstlisting}[frame=none, label={ublock}, caption={Managing an unblocked task.}, captionpos=b]
#if( configUSE_GP_SCHEDULER == 1 )
{
	vTaskComputePriority( pxTCB );
	listSET_LIST_ITEM_VALUE( &((pxTCB)->xStateListItem), 
							pxTCB->xPriorityValue );
	vaskComputePriority( pxCurrentTCB );
}
#endif
\end{lstlisting}
